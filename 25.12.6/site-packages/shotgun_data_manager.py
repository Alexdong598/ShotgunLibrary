import importlib
import sys
import os
import re
import ast # <-- 确保这一行在文件顶部！
from typing import List, Dict
import collections

# 定义需要重新加载的依赖模块
# 这些模块通常包含配置、凭据或不经常变动但可能在开发时需要更新的辅助函数
DEPENDENT_MODULE_NAMES = [
    "sg_register",  # 假设 sg_register.py 模块名为 sg_register
    "env",          # 假设 env.py 模块名为 env
]

# 全局管理器实例，用于存储 ShotgunDataManager 对象
_manager_instance = None

def get_command():
    """
    提供一个工厂函数，用于在外部获取 ShotgunDataManager 实例。
    这个函数本身不直接创建实例，而是调用 execute()。
    """
    def _command():
        try:
            # 调用 execute() 来获取或刷新管理器实例
            manager = execute()
            return manager
        except Exception as e:
            print(f"Failed to get command: {str(e)}")
            import traceback
            traceback.print_exc()
            return None # 返回None表示失败
    return _command

def execute():
    """
    执行模块的主要功能：初始化或重新初始化 ShotgunDataManager。
    此函数会尝试重新加载依赖模块和当前模块，以实现热更新。
    """
    global _manager_instance

    # --- 1. 重新加载依赖模块 ---
    # 遍历并重新加载所有在DEPENDENT_MODULE_NAMES中列出的模块
    for module_name in DEPENDENT_MODULE_NAMES:
        # 只有当模块已经被导入到sys.modules中时才尝试重新加载
        if module_name in sys.modules:
            try:
                importlib.reload(sys.modules[module_name])
                print(f"Successfully reloaded dependent module: {module_name}")
            except Exception as e:
                # 重新加载失败通常意味着模块有语法错误或运行时错误
                print(f"Failed to reload dependent module '{module_name}': {e}")
                import traceback
                traceback.print_exc()
                raise # 如果依赖模块无法重新加载，通常意味着更严重的问题，直接抛出

    # --- 2. 重新加载当前模块 ---
    # 重新加载当前模块，确保ShotgunDataManager类定义是最新的
    try:
        importlib.reload(sys.modules[__name__])
        print(f"Successfully reloaded current module: {__name__}")
    except Exception as e:
        print(f"Failed to reload current module '{__name__}': {e}")
        import traceback
        traceback.print_exc()
        raise # 当前模块无法重新加载，必须抛出错误

    # --- 3. 清空旧的管理器实例 ---
    # 如果存在旧的实例，将其引用清空，并尝试删除它
    # 这确保了新的 ShotgunDataManager 实例将基于重新加载后的类定义创建
    if _manager_instance:
        try:
            # 显式删除引用，有助于Python的垃圾回收机制回收旧对象
            # 但请注意，如果外部仍有对旧实例的引用，它不会被立即回收
            del _manager_instance
            _manager_instance = None
            print("Cleared old _manager_instance.")
        except Exception as e:
            # 捕获清空旧实例时可能发生的任何错误（虽然不常见）
            print(f"Error during clearing old _manager_instance: {e}")
            pass # 忽略此错误，继续尝试创建新实例

    # --- 4. 创建新的管理器实例 ---
    try:
        print("Attempting to create ShotgunDataManager...")
        # 这里的 ShotgunDataManager() 应该引用的是重新加载后的类定义
        # 通过 sys.modules[__name__].ShotgunDataManager() 明确指定从当前模块获取
        _manager_instance = sys.modules[__name__].ShotgunDataManager()
        print("Successfully created ShotgunDataManager")
        print(f"Connected to Shotgun server: {_manager_instance.sg.server_info()}")
        print(f"Project: {_manager_instance.HAL_PROJECT}")
        print(f"User: {_manager_instance.HAL_USER_LOGIN}")
        return _manager_instance
    except Exception as e:
        print(f"Failed to create manager: {str(e)}")
        print("Please check your Shotgun credentials in sg_register.py")
        print("And verify environment variables in env.py")
        import traceback
        traceback.print_exc()
        raise # 抛出异常，因为管理器未能成功创建

# ==============================================================================
# ShotgunDataManager 类定义
# ==============================================================================

class ShotgunDataManager:
    def __init__(self):
        # 导入 Shotgun 凭据，确保每次都从最新的 sg_register 模块获取
        from sg_register import login_to_shotgun
        self.sg = login_to_shotgun()

        # 导入和使用环境配置，确保每次都从最新的 env 模块获取
        from env import env_config
        self.env = env_config

        # 加载环境变量
        self._load_env_vars()
        self.data_store = {}

    def _load_env_vars(self):
        """Load environment variables from env config"""
        self.HAL_PROJECT_SGID = int(self.env.HAL_PROJECT_SGID or 0)
        self.HAL_PROJECT = self.env.HAL_PROJECT
        self.HAL_USER_LOGIN = self.env.HAL_USER_LOGIN
        self.HAL_USER_ABBR = self.env.HAL_USER_ABBR
        self.HAL_TREE = self.env.HAL_TREE

        # Entity-specific variables
        if self.HAL_TREE == "assets":
            self.HAL_ASSET_SGID = int(self.env.HAL_ASSET_SGID or 0)
        elif self.HAL_TREE == "shots":
            self.HAL_SHOT_SGID = int(self.env.HAL_SHOT_SGID or 0)

    def extract_filename_from_url(self, url: str) -> str:
        """Extract base filename without extension from URL"""
        if not url:
            return "No Image"
        match = re.search(r'filename%3D%22([^%]+?)%22', url)
        if match:
            filename = match.group(1).split('.')[0]
            return re.sub(r'[^a-zA-Z0-9_-]', '_', filename)  # Sanitize
        return "Unparsable URL"

    def _categorize_version(self, version_data: Dict):
        """
        Categorize version by entity type using regex patterns from the 'code' field.
        This populates the 'category' key in the version_data dictionary for client-side use.
        """
        entity_type = version_data.get("entity", {}).get("type", "")
        code = version_data.get("code", "").lower()

        if entity_type == "Asset":
            pattern = r'(mdl|shd|rig|txt|cgfx-setup|cncpt|assy)'
            match = re.search(pattern, code)
            version_data["category"] = match.group(1) if match else "asset_unknown"

        elif entity_type == "Shot":
            pattern = r'(anim|cgfx|comp|layout|lgt|mm|matp|paint|roto|assy)'
            match = re.search(pattern, code)
            version_data["category"] = match.group(1) if match else "shot_unknown"

    def _get_version_number(self, version_code: str) -> int:
        """Extracts the numerical version from a version code (e.g., 'v009' -> 9)"""
        match = re.search(r'_v(\d+)', version_code)
        if match:
            return int(match.group(1))
        return 0

    # Helper to get abbreviation for filtering 'code' field
    def _get_category_abbreviation(self, category_name: str) -> str:
        """Map full category names to their code abbreviations."""
        CATEGORY_ABBREVIATIONS = {
            'characters': 'chr',
            'environments': 'env',
            'props': 'prp',
            'vehicles': 'veh',
            'cgfx': 'cgfx',
            # Add more as needed
        }
        return CATEGORY_ABBREVIATIONS.get(category_name.lower(), '')

    def find_files(self, tab_context: str = "", entity_type: str = "") -> List[Dict]:
            """
            Retrieve and categorize Version entities from Shotgun,
            with specific filtering based on tab_context and an explicitly provided entity_type.
            
            Args:
                tab_context: Context string in format "type_part/category_part" (e.g., "mdl/props", "anim/0010").
                            For shots, category_part should be the Sequence code (e.g., "0010").
                entity_type: The explicit entity type to query ("Asset" or "Shot"). This removes ambiguity.
            """
            # Verify necessary Shotgun custom fields exist on Version entity (only checking for sg_path_to_geometry)
            version_schema = self.sg.schema_field_read("Version")
            if "sg_path_to_geometry" not in version_schema:
                raise Exception("sg_path_to_geometry field undefined in Version entity.")

            # Base filters: Always filter by project and existing geometry path
            filters = [
                ["project", "is", {"type": "Project", "id": self.HAL_PROJECT_SGID}],
                ["sg_path_to_geometry", "is_not", None]
            ]

            # --- Fields to fetch ---
            fields = [
                "id", "code", "content", "sg_path_to_geometry", "image", "entity",
                "entity.Shot.sg_sequence",
                "entity.Asset.sg_asset_type",
            ]

            # Add context-based filtering if provided
            if tab_context and entity_type:
                print(f"Applying Shotgun filters based on context: {tab_context} for entity type: {entity_type}")
                try:
                    type_part, category_part = tab_context.split('/')

                    code_filters = []
                    
                    # --- NEW LOGIC: Directly use the entity_type parameter ---
                    if entity_type == "Asset":
                        filters.append(["entity", "type_is", "Asset"])
                        
                        abbreviation = self._get_category_abbreviation(category_part)
                        if abbreviation:
                            code_filters.append(["code", "contains", abbreviation])
                        
                        code_filters.append(["code", "contains", type_part])

                    elif entity_type == "Shot":
                        filters.append(["entity", "type_is", "Shot"])
                        
                        sequence_entity = self.sg.find_one(
                            "Sequence",
                            [["project", "is", {"type": "Project", "id": self.HAL_PROJECT_SGID}], ["code", "is", category_part]],
                            ["id"]
                        )
                        
                        if sequence_entity:
                            filters.append(["entity.Shot.sg_sequence", "is", {"type": "Sequence", "id": sequence_entity["id"]}])
                        else:
                            print(f"Warning: Sequence with code '{category_part}' not found in Shotgun. Skipping sequence filter.")
                        
                        code_filters.append(["code", "contains", type_part])

                    else:
                        print(f"Warning: Unknown entity_type '{entity_type}' received. Filtering only by code contains.")
                        code_filters.append(["code", "contains", type_part])
                        code_filters.append(["code", "contains", category_part])

                    if len(code_filters) == 1:
                        filters.append(code_filters[0])
                    elif len(code_filters) > 1:
                        filters.append({
                            "filter_operator": "and",
                            "conditions": code_filters,
                            "filters": code_filters
                        })

                except ValueError:
                    print(f"Warning: Single-part context '{tab_context}' received. Filtering by code contains the context name.")
                    filters.append(["code", "contains", tab_context])

                except Exception as e:
                    print(f"Error building Shotgun filters for context '{tab_context}': {e}")
                    import traceback
                    traceback.print_exc()

            print(f"filters is:{filters}")
            print(f"fields is{fields}")

            versions = self.sg.find("Version", filters, fields)
            print(f"Found {len(versions)} versions with geometry paths after Shotgun filtering.")

            for version in versions:
                geo_path_field = version.get('sg_path_to_geometry')
                if isinstance(geo_path_field, str) and geo_path_field.strip():
                    version['sg_path_to_geometry'] = [geo_path_field.strip()]
                elif geo_path_field is None:
                    version['sg_path_to_geometry'] = []
            
            latest_versions = {}
            for version in versions:
                geo_path_field = version.get('sg_path_to_geometry')
                if isinstance(geo_path_field, str):
                    try:
                        parsed_list = ast.literal_eval(geo_path_field)
                        if isinstance(parsed_list, list):
                            version['sg_path_to_geometry'] = parsed_list
                        else:
                            version['sg_path_to_geometry'] = [geo_path_field]
                    except (ValueError, SyntaxError) as e:
                        print(f"Warning: Failed to parse sg_path_to_geometry string '{geo_path_field}' for version {version.get('code')}: {e}")
                        version['sg_path_to_geometry'] = [geo_path_field]
                elif geo_path_field is None:
                    version['sg_path_to_geometry'] = []

            latest_versions = {}
            for version in versions:
                self._categorize_version(version)
                entity = version.get("entity", {})

                key = (entity.get("type"), entity.get("id"), version.get("category"))
                
                current_version_num = self._get_version_number(version.get("code", ""))
                existing_version_num = self._get_version_number(latest_versions.get(key, {}).get("code", ""))
                
                if key not in latest_versions or current_version_num > existing_version_num:
                    latest_versions[key] = version

            print(f"Filtered to {len(latest_versions)} latest versions (highest per category within the context).")
            for version in latest_versions.values():
                print(f"Processing latest version: {version.get('code')}")
                
                image_url = version.get("image", "")
                raw_filename = self.extract_filename_from_url(image_url)
                cleaned_filename = self._clean_shotgun_thumbnail_name(raw_filename)
                version["image"] = cleaned_filename
                self._print_version_paths(version)

            versions = list(latest_versions.values())

            if not versions:
                print("No versions found with geometry paths for the given context.")

            return versions

    def _clean_shotgun_thumbnail_name(self, filename):
        pattern = r'(_t(?:_\d+)?)$'
        cleaned_name = re.sub(pattern, '', filename)
        return cleaned_name

    def _print_version_paths(self, version: Dict):
        """Print full version name, geo path and thumbnail path"""
        print(f"Version Name: {version.get('code', 'N/A')}")
        # --- MODIFICATION: Added print statement for 'content' field ---
        print(f"Content Field: {version.get('content', '!!! NOT FOUND OR EMPTY !!!')}")
        print(f"Task Name Field: {version.get('sg_task_name', '!!! NOT FOUND OR EMPTY !!!')}")
        print(f"Entity Field: {version.get('entity', '!!! NOT FOUND OR EMPTY !!!')}")

        # --- END MODIFICATION ---
        print(f"Geometry Path: {version.get('sg_path_to_geometry', 'N/A')}")
        print(f"Thumbnail Path: {version.get('image', 'N/A')}")
        print("-" * 50)